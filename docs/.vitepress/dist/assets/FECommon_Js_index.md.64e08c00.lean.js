import{_ as e,H as t,o as c,c as r,C as s,a as l,J as o,E as p,V as a}from"./chunks/framework.0fd66c21.js";const Ds=JSON.parse('{"title":"JavaScript","description":"","frontmatter":{},"headers":[],"relativePath":"FECommon/Js/index.md","lastUpdated":null}'),i={name:"FECommon/Js/index.md"},y=a("",9),D=s("code",null,"var",-1),F=s("code",null,"let、const",-1),C=a("",1),A=a("",3),u=a("",3),d=a("",2),_=s("code",null,"Number",-1),f=a("",1),h=a("",3),g=a("",4),E=a("",3),b=a("",2),m=s("h3",{id:"_1-1-3-js逻辑结构➕对象操作",tabindex:"-1"},[l("1.1.3 JS逻辑结构➕对象操作 "),s("a",{class:"header-anchor",href:"#_1-1-3-js逻辑结构➕对象操作","aria-label":'Permalink to "1.1.3 JS逻辑结构➕对象操作"'},"​")],-1),v=s("li",null,"条件语句",-1),S=s("li",null,[l("循环语句 "),s("ul",null,[s("li",null,"for：原始遍历｜没有额外的函数调用栈和上下文、最简单"),s("li",null,"for-in：迭代字符串类型的键（包括自定义的）"),s("li",null,"for-of：遍历值｜可以正确响应return、break、continue #开发/新特性与标准/ES/es6")])],-1),T=a("",3),j=a("",1),P=a("",6),q=s("h3",{id:"_1-1-4-js函数-基于对象",tabindex:"-1"},[l("1.1.4 JS函数（基于对象） "),s("a",{class:"header-anchor",href:"#_1-1-4-js函数-基于对象","aria-label":'Permalink to "1.1.4 JS函数（基于对象）"'},"​")],-1),N=a("",1),I=a("",1),x=a("",4),k=s("strong",null,"立即",-1),V=s("code",null,"(匿名函数)()",-1),J=a("",1),w=s("li",null,[l("表达式函数：赋给变量的函数｜"),s("code",null,"var f = function (a, b) {}")],-1),R=s("code",null,"f1(){ f2(); retruun f2;}",-1),O=s("li",null,"构造函数：用于创建具有相同属性和方法的对象",-1),M=s("li",null,"生成器函数",-1),z=s("code",null,"export",-1),X=s("code",null,"import",-1),B=a("",1),H=a("",2),L=s("h3",{id:"_1-1-5-js面向对象-基于对象因此很灵活",tabindex:"-1"},[l("1.1.5 JS面向对象（基于对象因此很灵活） "),s("a",{class:"header-anchor",href:"#_1-1-5-js面向对象-基于对象因此很灵活","aria-label":'Permalink to "1.1.5 JS面向对象（基于对象因此很灵活）"'},"​")],-1),W=s("p",null,"^483845",-1),U=a("",1),$=s("ul",null,[s("li",null,"本质：基于构造函数和原型对象实现面向对象"),s("li",null,"特性：引用式传递，修改原型时，与之相关的对象也会继承"),s("li",null,[l("❓ new运算符的实现机制 "),s("ul",null,[s("li",null,"本质：先创建空对象，然后一通复制，内容包括构造函数的属性方法、还有原型"),s("li",null,"第一步，先创建空对象，它的原型用构造函数的"),s("li",null,"第二步，传参数赋值、方法都复制过来")])])],-1),Q=a("",3),Y=s("em",null,"proto",-1),G=a("",5),K=s("li",null,"原型链：用来收集和维护对象属性的一系列查询，可以链式的去找属性或方法",-1),Z=s("ul",null,[s("li",null,"static：静态"),s("li",null,"super：继承"),s("li",null,"extends：继承关系"),s("li",null,"constructor：可以直接从对象指向它的构造函数")],-1),ss=a("",5),ls=s("li",null,[l("EventLoop事件循环机制：永不阻塞 ^157d68 "),s("ul",null,[s("li",null,"当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码"),s("li",null,"先执行栈里的同步代码，然后再执行异步队列的异步代码")])],-1),as=s("ul",null,[s("li",null,"约定：本轮事件循环运行完成前，不会回调；异步操作不论成功失败，都会调用then()中的回调；多次调用then()可添加多个回调，按顺序执行；"),s("li",null,"参数：函数(resolve、reject)"),s("li",null,[l("方法：then、catch "),s("ul",null,[s("li",null,"then中的回调函数必需有返回；"),s("li",null,"catch可以捕获一次异常的回调失败；如果有需要可以继续then"),s("li",null,"catch和try...catch很像")])])],-1),ns=a("",12);function os(ps,es,ts,cs,rs,is){const n=t("font");return c(),r("div",null,[y,s("ul",null,[s("li",null,[l("数据类型与变量 "),o(n,{color:"#ff0000"},{default:p(()=>[l("【面试常考】")]),_:1}),s("ul",null,[s("li",null,[l("变量声明➕ 作用域➕特性 ^39a766 "),s("ul",null,[s("li",null,[D,l("和"),F,l("：作用域、变量提升、重复声明 "),s("ul",null,[s("li",null,[o(n,{color:"#f79646"},{default:p(()=>[l("在开发中，要尽量少用var（语义不不明确、作用域问题）；优先用const，当知道会改变时用let；")]),_:1}),l(" #开发/技术/FE/js/exp")]),s("li",null,[l("var：函数作用域、可修改、变量不声明默认是var声明、不初始化是undefined；有变量提升、可重复声明｜"),o(n,{color:"#d99694"},{default:p(()=>[l("var配合for循环有bug")]),_:1}),C]),A])]),u])]),s("li",null,[l("数据类型 ^847721 "),s("ul",null,[s("li",null,[l("原始数据类型（7种）：是值 | 存值 | 在栈上、没有函数 "),s("ul",null,[d,s("li",null,[l("数字("),_,l(")："),o(n,{color:"#dbe5f1"},{default:p(()=>[l("唯一数字类型是浮点：0.1+0.2!=0.3")]),_:1}),f]),h])]),g])]),E])]),b]),m,s("ul",null,[v,S,s("li",null,[l("对象操作 "),s("ul",null,[T,s("li",null,[l("循环过滤：filter()、map() "),s("ul",null,[s("li",null,[l("✅ Array.filter(callback)，对每个数组的元素做callback测试，返回true则存入新数组，最终返回该数组，不修改原数组｜"),o(n,{color:"#d99694"},{default:p(()=>[l("前端没分页的列表查找，搜索也叫过滤，如果是精确搜索用find找")]),_:1})]),j])]),P])])]),q,s("ul",null,[N,s("li",null,[l("🚩函数：可调用的用于执行代码的对象｜"),o(n,{color:"#b7dde8"},{default:p(()=>[l("通过 声明、匿名、表达式、箭头 定义")]),_:1}),l("｜无重载的覆盖、return非必需 "),I]),x,s("li",null,[l("🚩 立即执行函数（IIFE）：定义后"),k,l("被执行｜"),V,l("｜"),o(n,{color:"#fac08f"},{default:p(()=>[l("定义模块化方法，私有域避免污染，大佬库必备")]),_:1}),l(" ^c74f86 "),J]),w,s("li",null,[l("高阶函数（闭包）：一个返回内部定义的函数的函数｜"),R,l("｜"),o(n,{color:"#fac08f"},{default:p(()=>[l("私有域起变量保护作用、不回收、创建模块")]),_:1})]),O,M,s("li",null,[l("🚩 jS模块化：用于导出、引入所需模块｜"),z,l("、"),X,l("｜"),o(n,{color:"#fac08f"},{default:p(()=>[l("封装打包复用")]),_:1}),l("｜"),o(n,{color:"#ffff00"},{default:p(()=>[l("主题定制、国际化")]),_:1}),l(" #开发/新特性与标准/ES/es6 ^903d7f "),B]),H]),L,W,s("ul",null,[U,s("li",null,[l("🚩 对象：对象或实例｜"),o(n,{color:"#b7dde8"},{default:p(()=>[l("内置对象；通过字面量、new调用构造函数批量、class批量 生成")]),_:1}),l("｜"),o(n,{color:"#fac08f"},{default:p(()=>[l("面向对象、动态修改")]),_:1}),$]),s("li",null,[l("⭐️ 构造函数：一种用来创建相同属性方法的对象的函数｜"),o(n,{color:"#b7dde8"},{default:p(()=>[l("通过 函数声明、函数表达式、class 定义")]),_:1}),s("ul",null,[s("li",null,[o(n,{color:"#f79646"},{default:p(()=>[l("构造函数的优化使用原型添加方法，避免重复调用构造函数创建对象时重复执行代码")]),_:1}),l(" #开发/技术/FE/js/exp ")]),Q])]),s("li",null,[l("🚩 原型对象：创建对象 或 函数时默认存在的属性｜"),o(n,{color:"#b7dde8"},{default:p(()=>[l("通过 函数名 或 类名.prototype、对象 或 实例."),Y,l(" 访问修改")]),_:1}),l("｜"),o(n,{color:"#fac08f"},{default:p(()=>[l("实现继承、共有关系；手撕语法糖")]),_:1}),s("ul",null,[s("li",null,[o(n,{color:"#f79646"},{default:p(()=>[l("对象._proto_是非标准的、usestrict下可能异常，尽量避免，用Object.getPrototypeOf(obj)和～set～代替操作；可以用prototype增加共有属性方法来优化代码；prototype或_proto_修改，实例也能够动态变化，因此要注意避免覆盖、重复修改，尽量创建时设置好。")]),_:1}),l(" #开发/技术/FE/js/exp")]),G])]),K,s("li",null,[l("⭐️ 类class、super、constructor及其相关：构造函数与原型的语法糖｜"),o(n,{color:"#fac08f"},{default:p(()=>[l("优雅地生成对象、继承对象")]),_:1}),l(" #开发/新特性与标准/ES/es6 ^a8b012 "),Z])]),ss,s("ul",null,[ls,s("li",null,[l("Promise：一种链式调用的异步操作｜"),o(n,{color:"#b7dde8"},{default:p(()=>[l("当函数返回Promise对象时可以通过.then来做异步操作")]),_:1}),l("｜"),o(n,{color:"#d99694"},{default:p(()=>[l("链式调用、简化回调失败的代码（只要一次）、可以封装旧式的回调API")]),_:1}),l("｜"),o(n,{color:"#953734"},{default:p(()=>[l("复杂时臃肿")]),_:1}),l("｜"),o(n,{color:"#c3d69b"},{default:p(()=>[l("建议箭头函数表示")]),_:1}),l(" ^472653 "),as])]),ns])}const Fs=e(i,[["render",os]]);export{Ds as __pageData,Fs as default};
